#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <getopt.h>
#include <string.h>

#include <zlib.h>
#include <seqtk/kseq.h>

#include <ac.h>

//not including double stop codons, but including revcomp ones
#define MAX_STOP_CODONS 10

///////// (MOSTLY) AUTOGENERATED CODE, DO NOT EDIT DIRECTLY ////////////////////////////////////////////////////////////////
char codonTable1[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', '*', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable2[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', '*', 'S', '*', 'S', 'M', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable3[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'M', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'T', 'T', 'T', 'T', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable4[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable5[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'S', 'S', 'S', 'S', 'M', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable6[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', 'Q', 'Y', 'Q', 'Y', 'S', 'S', 'S', 'S', '*', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable9[] = {
    'N', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'S', 'S', 'S', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable10[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'C', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable11[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', '*', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable12[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'S', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', '*', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable13[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'G', 'S', 'G', 'S', 'M', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable14[] = {
    'N', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'S', 'S', 'S', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', 'Y', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable16[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', 'L', 'Y', 'S', 'S', 'S', 'S', '*', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable21[] = {
    'N', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'S', 'S', 'S', 'S', 'M', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable22[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', 'L', 'Y', '!', 'S', 'S', 'S', '!', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable23[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '!', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', '*', 'C', 'W', 'C', '!', 'F', 'L', 'F'
};
char codonTable24[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'S', 'S', 'K', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'W', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char codonTable25[] = {
    'K', 'N', 'K', 'N', 'T', 'T', 'T', 'T', 'R', 'S', 'R', 'S', 'I', 'I', 'M', 'I', 'Q', 'H', 'Q', 'H', 'P', 'P', 'P', 'P', 'R', 'R', 'R', 'R', 'L', 'L', 'L', 'L', 'E', 'D', 'E', 'D', 'A', 'A', 'A', 'A', 'G', 'G', 'G', 'G', 'V', 'V', 'V', 'V', '*', 'Y', '*', 'Y', 'S', 'S', 'S', 'S', 'G', 'C', 'W', 'C', 'L', 'F', 'L', 'F'
};
char* codonTableSuite[] = {
NULL,
codonTable1,
codonTable2,
codonTable3,
codonTable4,
codonTable5,
codonTable6,
NULL,
NULL,
codonTable9,
codonTable10,
codonTable11,
codonTable12,
codonTable13,
codonTable14,
NULL,
codonTable16,
NULL,
NULL,
NULL,
NULL,
codonTable21,
codonTable22,
codonTable23,
codonTable24,
codonTable25
};
int num_translation_tables = 25;
/////////////// END AUTOGENERATED SECTION ////////////////////////////////////////////////////////////////




KSEQ_INIT(gzFile, gzread)

char* for_printing;
char* revcom_lookup_table;

typedef struct {
  AC_STRUCT * ac;
  int num_stop_codons;
  char** stop_codons;
} stop_codon_search_data;

void translate(char* begin, int num, bool reverse, char* codonTable){
//   char* tmp = malloc(10000); printf("%s %i\n", strncpy(tmp, begin, num), reverse); free(tmp);
  for_printing = realloc(for_printing, (num/3) + 1);
  int j=0;
  if (reverse){
    num -= 3;
    for(;num >= 0; num-=3){
      for_printing[j] = codonTable[ 128 + (*(begin+num+2)<<16) + (*(begin+num+1)<<8) + *(begin+num)];
      j++;
    }
  } else {
    int i;
    for(i=0; i<num; i+=3){
      for_printing[j] = codonTable[ (*(begin+i)<<16) + (*(begin+i+1)<<8) + *(begin+i+2)];
      j++;
    }
  }
  for_printing[j] = 0;
  puts(for_printing);
}

inline void print_sequence_header(kseq_t* seq_struct, int start_position, int frame, int orf_counter){
  if (seq_struct->comment.l > 0){
    printf(">%s_%i_%i_%i %s\n", seq_struct->name.s, start_position+1, frame, orf_counter, seq_struct->comment.s);
  } else {
    printf(">%s_%i_%i_%i\n", seq_struct->name.s, start_position+1, frame, orf_counter);
  }
}
inline void print_transcript_sequence_header(kseq_t* seq_struct, int start_position, int frame, int orf_counter, FILE* transcript_output_fp){
  if (seq_struct->comment.l > 0){
    fprintf(transcript_output_fp, ">%s_%i_%i_%i %s\n", seq_struct->name.s, start_position+1, frame, orf_counter, seq_struct->comment.s);
  } else {
    fprintf(transcript_output_fp, ">%s_%i_%i_%i\n", seq_struct->name.s, start_position+1, frame, orf_counter);
  }
}

inline void print_sequence(kseq_t* sequence,
                           FILE* transcript_output_fp,
                           char* codonTable,
                           int *orf_counter,
                           bool is_reverse_direction,
                           int start_position,
                           int nucleotide_sequence_length,
                           int frame){
  // print transcripts if needed
  if (transcript_output_fp){
    print_transcript_sequence_header(sequence, start_position, frame, *orf_counter, transcript_output_fp);
    if (is_reverse_direction){
      for_printing = realloc(for_printing, nucleotide_sequence_length);
      int i;
      for (i=0; i<nucleotide_sequence_length; i++){
        for_printing[nucleotide_sequence_length-i-1] = revcom_lookup_table[(int)(sequence->seq.s[i+start_position])];
      }
      fprintf(transcript_output_fp, "%.*s\n", nucleotide_sequence_length, for_printing);
    } else {
      fprintf(transcript_output_fp, "%.*s\n",
              nucleotide_sequence_length,
              sequence->seq.s+start_position);
    }
  }
  // print amino acids
  print_sequence_header(sequence, start_position, frame, *orf_counter);
  translate(sequence->seq.s+start_position,
            nucleotide_sequence_length,
            is_reverse_direction, codonTable);
  // keep counting
  (*orf_counter)++;
}


/** Create an index that maps 3 base codons (the bits from 3 chars)
    to the amino acid that they encode, with X for non-DNA bases.
    The reverse complements are encoded as +128 since A, T, G, C, a, t, g, c are
    all less than 128 bits.
    */
char* create_codon_table(char* input_codon_table){
  int table_size = (1<<8)*(1<<8)*(1<<8) * sizeof(char); //3 bases per codon indexed to another char
  char* faster_table = (char*) malloc(table_size);

  char* order = "ACGT";
  char* low_order = "acgt";
  char* complements = "TGCA";
  char* low_complements = "tgca";
  int i,j,k,count;
  for (i=0; i<table_size; i++)
    faster_table[i] = 'X';
  count = 0;
  for (i=0; i<4; i++){
    for (j=0; j<4; j++){
      for (k=0; k<4; k++){
        //fwd
        faster_table[(order[i]<<16) + (order[j]<<8) + order[k]] = input_codon_table[count];
        faster_table[(order[i]<<16) + (order[j]<<8) + low_order[k]] = input_codon_table[count];
        faster_table[(order[i]<<16) + (low_order[j]<<8) + order[k]] = input_codon_table[count];
        faster_table[(order[i]<<16) + (low_order[j]<<8) + low_order[k]] = input_codon_table[count];
        faster_table[(low_order[i]<<16) + (low_order[j]<<8) + order[k]] = input_codon_table[count];
        faster_table[(low_order[i]<<16) + (low_order[j]<<8) + low_order[k]] = input_codon_table[count];
        faster_table[(low_order[i]<<16) + (order[j]<<8) + order[k]] = input_codon_table[count];
        faster_table[(low_order[i]<<16) + (order[j]<<8) + low_order[k]] = input_codon_table[count];

        //encode the reverse complement of the codon matching to the same amino acid
        faster_table[128 + (complements[i]<<16) + (complements[j]<<8) + complements[k]] = input_codon_table[count];
        faster_table[128 + (complements[i]<<16) + (complements[j]<<8) + low_complements[k]] = input_codon_table[count];
        faster_table[128 + (complements[i]<<16) + (low_complements[j]<<8) + complements[k]] = input_codon_table[count];
        faster_table[128 + (complements[i]<<16) + (low_complements[j]<<8) + low_complements[k]] = input_codon_table[count];
        faster_table[128 + (low_complements[i]<<16) + (complements[j]<<8) + complements[k]] = input_codon_table[count];
        faster_table[128 + (low_complements[i]<<16) + (complements[j]<<8) + low_complements[k]] = input_codon_table[count];
        faster_table[128 + (low_complements[i]<<16) + (low_complements[j]<<8) + complements[k]] = input_codon_table[count];
        faster_table[128 + (low_complements[i]<<16) + (low_complements[j]<<8) + low_complements[k]] = input_codon_table[count];

        count += 1;
      }
    }
  }

  return faster_table;
}

char* create_revcom_lookup_table(){
  revcom_lookup_table = (char*) malloc( 1<<8 * sizeof(char));
  char* order = "ACGTN";
  char* complements = "TGCAN";
  int i;
  for (i=0; i<(1<<8); i++){
    revcom_lookup_table[i] = 'N';
  }
  for (i=0; i<strlen(order); i++){
    revcom_lookup_table[(int)order[i]] = complements[i];
    revcom_lookup_table[(int)tolower(order[i])] = tolower(complements[i]);
  }
  return revcom_lookup_table;
}


stop_codon_search_data* create_stop_codon_search_structure(char* codonTable, char* revcom_lookup_table){
  stop_codon_search_data* data = malloc(sizeof(stop_codon_search_data));

  data->ac = ac_alloc();

  //first work out how many stop codons there are
  int stop_codon_count = 0;
  int i=0;
  for (i=0; i<64; i++){
    if (codonTable[i] == '*')
      stop_codon_count++;
  }
  data->num_stop_codons = stop_codon_count;

  // search through the array, searching for stop codons. Add the corresponding codon
  // to the search structure
  i=0;
  stop_codon_count = 0;
  char* order = "ACGT";
  char codon[3];
  int j,k,l;
  int double_stop_codon_count = MAX_STOP_CODONS;
  for (j=0; j<4; j++){
    for (k=0; k<4; k++){
      for (l=0; l<4; l++){
        if (codonTable[i] == '*'){
          stop_codon_count++;
          codon[0] = order[j];
          codon[1] = order[k];
          codon[2] = order[l];
          ac_add_string(data->ac, codon, 3, stop_codon_count);
        } else if (codonTable[i] =='!'){
          double_stop_codon_count++;
          codon[0] = order[j];
          codon[1] = order[k];
          codon[2] = order[l];
          ac_add_string(data->ac, codon, 3, double_stop_codon_count);
        }
        i++;
      }
    }
  }

  //add the reverse complements
  i=0;
  for (j=0; j<4; j++){
    for (k=0; k<4; k++){
      for (l=0; l<4; l++){
        if (codonTable[i] == '*'){
          stop_codon_count++;
          codon[2] = revcom_lookup_table[(int)order[j]];
          codon[1] = revcom_lookup_table[(int)order[k]];
          codon[0] = revcom_lookup_table[(int)order[l]];
          ac_add_string(data->ac, codon, 3, stop_codon_count);
        }
        i++;
      }
    }
  }

  ac_prep(data->ac);
  return data;
}


void process_sequence_file(char *path, int min_length, char* codonTable, int position_limit, char* output_transcript_path){
  char *search_result;
  int length_out, id_out, ends_at;
  int mod3;
  int length_to_string_start;

  revcom_lookup_table = create_revcom_lookup_table();
  stop_codon_search_data* data = create_stop_codon_search_structure(codonTable, revcom_lookup_table);
  AC_STRUCT * ac = data->ac;
  int num_stop_codons = data->num_stop_codons;
  free(data);

  for_printing = (char *) malloc(1);

  FILE* transcript_output_fp = NULL;
  if (output_transcript_path){
    transcript_output_fp = fopen(output_transcript_path,"w");
    if (transcript_output_fp ==NULL){
      printf("Cannot open output transcript file '%s' for writing\n", output_transcript_path);
      exit(5);
    }
  }

  //setup kseq reading
  gzFile fp;
  if (path == NULL){
    fp = gzopen("/dev/stdin","r");
  } else {
    fp = gzopen(path, "r");
  }

  //read in one sequence at a time, looping
  kseq_t *seq;
  int l;
  seq = kseq_init(fp);
  int read_position_limit;
  codonTable = create_codon_table(codonTable);

  while ((l = kseq_read(seq)) >= 0) {
    //if there is no chance of getting an ORF here, don't even start
    if (seq->seq.l < min_length){
      continue;
    }
    //printf("Processing sequence %s\n",seq->seq.s);
    if (!position_limit || seq->seq.l < position_limit){
      read_position_limit = seq->seq.l;
    } else {
      read_position_limit = position_limit;
    }

    //set current positions for each of the frames
    int last_found_positions[6] = {0,1,2,0,1,2};
    int orf_counter = 1;

    //search for forward facing stop codons
    ac_search_init(ac, seq->seq.s, read_position_limit);

    //for each found position,
    while ((search_result = ac_search(ac, &length_out, &id_out, &ends_at)) != NULL){
      //find the frame of the position using mod 3 operation
      length_to_string_start = search_result - seq->seq.s;
      mod3 = length_to_string_start % 3;
      //       printf("Found potential ORF at position %i given found string id %i. Current positions are %i,%i,%i %i,%i,%i and mod3 %i from total sequence length %i and ORF length %i\n",
      //              length_to_string_start,
      //              id_out,
      //              last_found_positions[0],
      //              last_found_positions[1],
      //              last_found_positions[2],
      //              last_found_positions[3],
      //              last_found_positions[4],
      //              last_found_positions[5],
      //              mod3,
      //              (int)read_position_limit,
      //              length_to_string_start - last_found_positions[mod3]
      //             );

      //if current position - last position >= min_length, translate and spit out translated sequence
      if (id_out <= num_stop_codons) {
        //in fwd direction is this ORF
        if (length_to_string_start - last_found_positions[mod3] >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[mod3], length_to_string_start - last_found_positions[mod3], mod3+1);
        }
        //last_position[frame] = current_position (for next time)
        last_found_positions[mod3] = length_to_string_start+3;

      } else if (id_out < MAX_STOP_CODONS) { //if id of ac hit is 3 or more but not a stop codon in both directions, spit out the reverse complement
        if (length_to_string_start - last_found_positions[mod3+3] >= min_length){
          //spit out revcom sequence
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[mod3+3], length_to_string_start - last_found_positions[mod3+3], mod3+4);
        }
        last_found_positions[mod3+3] = length_to_string_start+3;
        
      } else {
        // Unusual codons like TCA and TGA are both stop codons and are reverse complements of each other. So print sequences in both directions.
        if (length_to_string_start - last_found_positions[mod3] >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[mod3], length_to_string_start - last_found_positions[mod3], mod3+1);
        }
        last_found_positions[mod3] = length_to_string_start+3;
        if (length_to_string_start - last_found_positions[mod3+3] >= min_length){
          //spit out revcom sequence
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[mod3+3], length_to_string_start - last_found_positions[mod3+3], mod3+4);
        }
        last_found_positions[mod3+3] = length_to_string_start+3;        
      }
    } //end while finding matches



    //then check for the last ORF in each of the frames
    mod3 = read_position_limit % 3;
    //     printf("Final positions: %i,%i,%i %i,%i,%i and mod3 %i from length %i\n",
    //            last_found_positions[0],
    //            last_found_positions[1],
    //            last_found_positions[2],
    //            last_found_positions[3],
    //            last_found_positions[4],
    //            last_found_positions[5],
    //            mod3,
    //            (int)read_position_limit
    //           );
    switch (mod3){
      case 0:
        //translate each of the frames in order
        //for the 1st and 4th frames translate (length-last)bp
        //for the 2,3,5,6th frames translate (length-last-3-{2,1})bp
        if ((l = read_position_limit - last_found_positions[0]) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[0], l, 1);
        }
        if ((l = read_position_limit - last_found_positions[1] - 2) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[1], l, 2);
        }
        if ((l = read_position_limit - last_found_positions[2] - 1) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[2], l, 3);
        }
        if ((l = read_position_limit - last_found_positions[3]) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[3], l, 4);
        }
        if ((l = read_position_limit - last_found_positions[4] - 2) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[4], l, 5);
        }
        if ((l = read_position_limit - last_found_positions[5] - 1) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[5], l, 6);
        }
        break;
      case 1:
        if ((l = read_position_limit - last_found_positions[0] - 1) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[0], l, 1);
        }
        if ((l = read_position_limit - last_found_positions[1]) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[1], l, 2);
        }
        if ((l = read_position_limit - last_found_positions[2] - 2) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[2], l, 3);
        }
        if ((l = read_position_limit - last_found_positions[3] - 1) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[3], l, 4);
        }
        if ((l = read_position_limit - last_found_positions[4]) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[4], l, 5);
        }
        if ((l = read_position_limit - last_found_positions[5] - 2) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[5], l, 6);
        }
        break;
      case 2:
        if ((l = read_position_limit - last_found_positions[0] - 2) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[0], l, 1);
        }
        if ((l = read_position_limit - last_found_positions[1] - 1) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[1], l, 2);
        }
        if ((l = read_position_limit - last_found_positions[2]) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, false, last_found_positions[2], l, 3);
        }
        if ((l = read_position_limit - last_found_positions[3] - 2) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[3], l, 4);
        }
        if ((l = read_position_limit - last_found_positions[4] - 1) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[4], l, 5);
        }
        if ((l = read_position_limit - last_found_positions[5]) >= min_length){
          print_sequence(seq, transcript_output_fp, codonTable, &orf_counter, true, last_found_positions[5], l, 6);
        }
        break;
    }
  } //onto next sequence

  //cleanup
  if (output_transcript_path)
    free(revcom_lookup_table);
  free(codonTable);
  free(for_printing);
  kseq_destroy(seq);
  ac_free(ac);
  gzclose(fp);
}

/* Return true if the current_version (i.e. ORFM_VERSION) is >= required_version.
The input strings are modified. Not thread-safe since strtok is not thread-safe. */
bool compare_version(char* required_version, char* current_version){
  char *s1;
  char *s2;
  char *s3;
  int r1, r2, r3, c1, c2, c3;
  s1 = (char *) strtok(required_version, ".");
  s2 = (char *) strtok(NULL, ".");
  s3 = (char *) strtok(NULL, ".");
  if (s1 == NULL || s2 == NULL || s3 == NULL || strtok(NULL, ".") != NULL){
    fprintf(stderr, "Unexpected format of version string, I required something like 0.1.4\n");
    exit(4);
  }
  r1 = atoi(s1);
  r2 = atoi(s2);
  r3 = atoi(s3);

  char *current_version2 = malloc((1+strlen(current_version))*sizeof(char));
  strcpy(current_version2, current_version);
  c1 = atoi(strtok(current_version2, "."));
  c2 = atoi(strtok(NULL, "."));
  c3 = atoi(strtok(NULL, "."));
  free(current_version2);

  if (r1 < c1) return true;
  else if (r1 > c1) return false;
  if (r2 < c2) return true;
  else if (r2 > c2) return false;
  if (r3 <= c3) return true;
  else return false;
}


int main(int argc, char *argv[]){
  int min_length = 96;
  char c;
  int table_number;
  char* codonTable = codonTable1;
  int position_limit = 0;
  char* required_version;
  char* output_transcript_path = NULL;

  while ((c = getopt(argc, argv, "hvm:l:r:t:c:")) != -1){
    switch (c){
      case 'v':
        printf("OrfM version %s\n",ORFM_VERSION);
        exit(0);
      case 'h':
        printf("\n  Usage: orfm [options] <seq_file>\n\n");
        printf("  The <seq_file> can be a FASTA or FASTQ file, gzipped or uncompressed.\n\n");
        printf("  Options:\n");
        printf("   -m LENGTH   minimum number of nucleotides (not amino acids) to call an ORF on [default: %i]\n", min_length);
        printf("   -t FILE     output nucleotide sequences of transcripts to this path [default: none]\n");
        printf("   -l LENGTH   ignore the sequence of the read beyond this, useful when comparing reads from with different read lengths [default: none]\n");
        printf("   -c TABLE_ID codon table for translation (see http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes for details) [default: 1]\n");
        printf("   -v          show version information\n");
        printf("   -h          show this help\n");
        printf("   -r VERSION  do not run unless this version of OrfM is at least this version number (e.g. %s)\n",ORFM_VERSION);
        printf("\n");
        exit(0);
      case 'm':
        min_length = atoi(optarg);
        if (min_length < 3){
          fprintf(stderr, "ERROR: -m minimum length must be 3 or more\n");
          exit(1);
        }
        if (min_length % 3 != 0){
          fprintf(stderr, "ERROR: -m minimum length argument must be a multiple of 3\n");
          exit(2);
        }
        break;
      case 'l':
        position_limit = atoi(optarg);
        if (position_limit < 3){
          fprintf(stderr, "ERROR: -l must be 3 or more\n");
          exit(1);
        }
        break;
      case 'r':
        required_version = malloc((1+strlen(optarg))*sizeof(char));
        strcpy(required_version, optarg);
        if (!compare_version(required_version, ORFM_VERSION)){
          fprintf(stderr, "ERROR: this version of OrfM is older than the required version; please upgrade OrfM\n");
          free(required_version);
          exit(3);
        }
        free(required_version);
        break;
      case 'c':
        table_number = atoi(optarg);
        if (table_number < 1 || table_number > num_translation_tables || codonTableSuite[table_number] == NULL){
          fprintf(stderr, "Invalid translation table specified\n");
          exit(4);
        }
        codonTable = codonTableSuite[table_number];
        break;
      case 't':
        output_transcript_path = optarg;
        break;
    }
  }

  if (position_limit != 0 && min_length > position_limit){
    fprintf(stderr, "-l cannot be greater than -m, otherwise no ORFs are possible\n");
    exit(4);
  }
  //printf("Processing sequence file %s with min_length %i\n", argv[optind], min_length);
  if (argc-optind == 0){
    process_sequence_file(NULL, min_length, codonTable, position_limit, output_transcript_path);
  } else if (argc-optind == 1){
    process_sequence_file(argv[optind], min_length, codonTable, position_limit, output_transcript_path);
  } else {
    fprintf(stderr, "ERROR: one file at most can be given as an argument, found %i\n", argc-optind);
    exit(3);
  }

  return 0;
}
